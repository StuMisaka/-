## 快速响应的用户界面

### 浏览器UI线程

浏览器的UI线程基于一个简单的工作队列，一个任务被完成后再进行下一个。所有的用户交互都会立刻触发UI更新，如果用户试图在任务运行期间与页面交互，不仅没有即时的UI更新，甚至可能新的UI更新任务都不会被创建并加入队列。所以Js任务必须要尽快结束。

###　浏览器限制

浏览器通常会限制Js任务的运行时间。此类限制通常分两种：调用栈大小限制和长时间运行限制。所谓的长不同浏览器有不同的限制方法，可能是脚本长度可能是运行时长。可用性专家Jakob Nielsen指出，如果界面在100ms内响应用户输出，那么用户会认为自己在直接操纵界面对象，超过100ms则会感到失去联系。所以尽可能让js执行时间短，通常超过100ms的脚本是因为发生了错误。

### 使用定时器让出时间片段

定时器会告诉Js引擎先等待一段时间，然后添加一个Js任务到UI队列。

```js
function greeting(){
	alert('hello');
}
setTimeout(greeting,250)
```

这段代码将在250ms，向UI队列插入一个执行greeting()函数的Js任务，在这时间点前，所有其他的UI更新和Js任务都将正常执行不受影响。250ms仅仅代表在250ms后加入队列，并不保证在250ms后执行，因为250ms后可能队列并不为空。

### 定时器精度

Js的定时器通常不太准确，相差大概几毫秒。所以定时器不能用来测量实际时间。

### 定时器处理长数组

定时器分割任务以免一个任务时间太长。

```js
var todo = items.concat();
setTimeout(function(){
	process(todo.shift);
	if(todo.length > 0){
		setTimeout(arguments.callee,25);
	}else{
		callback(items);
	}
})
```

对于一个长数组，可能全部处理完需要1s以上，分割后每批只有25ms延迟，用户不会觉察到界面阻塞。

### 定时器与性能

如果同时有多个定时器创建往往会发生性能问题。比较好的建议是限制高频率定时器的数量或创建一个独立的重复定时器，每次执行多个操作。

## 编程实践

### 避免双重求值

Js允许在程序中提取一个包含代码的字符串，然后动态执行它。例如在`setTimeout()`,`setInterval()`中那样。这样的情况会导致双重求值，此代码首先会以正常的方式求值，然后在执行过程中对包含于字符串中的代码发请另一个求值运算。双重求值是代价昂贵的，尽可能避免它，比如直接传入一个函数而并非是字符串。

### 使用Object/Array直接量

```js
var myObject = new Object();
```

```js
var myObject = {
   ......
}
```

后者的速度明显快于前者，所以使用直接字面量有利于性能提升。

### 位运算的优越

位运算具备比普通数学运算更快的速度，在可能的地方尽可能使用位运算。

例如：

```js
i % 2
```

```js
i & 2
```

两种写法均用于对二取模，但是位运算的速度要更快。

### 原生方法

Js提供的原生方法具备更好的性能，因为它们都是用低级语言写成，并已经存在于浏览器中。一个例子就是熟练使用Math对象中的方法而不是手动编写运算过程。

另一个例子是原生的`querySelector()`和`querySelectorAll()`要比jQuery快。