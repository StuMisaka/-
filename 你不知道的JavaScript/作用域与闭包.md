## 作用域

### 编译原理

尽管通常将JavaScript归类为“动态”或“解释执行”语言，但实际上它是一门编译语言。但与传统的编译语言不同，JavaScript不是提前编译的，编译结果也不能在分布式系统中进行移植。

对一般的编译语言来说，编译过程包括三个部分

1. 分词/词法分析(Tokenizing/Lexing)

2. 解析/语法分析(Parsing)

3. 代码生成

而对于JS引擎来说，它不会有大量的时间来对代码进行优化，它的编译过程往往发生在执行前的几微秒甚至更短。

### LHS与RHS

当变量出现在赋值操作左侧时会进行LHS查询，出现在右侧则进行RHS查询。更好理解的说法是：赋值操作的目标是谁（LHS）以及谁是赋值操作的源头(RHS)。

LHS和RHS查询都会从当前执行作用域开始，如果有需要（没有在当前作用域找到标识符），就会继续向上级作用域查找标识符，直到抵达全局作用域。

不成功的RHS会抛出ReferenceError异常，而不成功的LHS会导致隐式创建一个全局变量（非严格模式下）。

### 词法作用域

#### 查找

作用域查找会从运行时的最内部作用域开始，逐级向外或者说向上开始查询，直到遇到第一个匹配的标识符开始。

（如果多层嵌套的作用域内定义了同名的标识符，则会发生“遮蔽”）。

*全局变量会自动成为全局对象的属性，可以直接通过对全局对象属性的引用来进行访问 例如window.a*

#### 欺骗词法

有两种机制可以修改一般情况下的词法作用域

*但是欺骗词法作用域会导致性能下降*

##### eval语句

```js
function foo(str,a){
	eval(str);
	console.log(a,b);
}
var b = 2;

foo("var b = 3;",1)   //1,3
```

eval语句会使`var b = 3;`就像原本就在eval语句处那样，因此它实际对`foo()`的词法作用域做出了修改。本质上，它在`foo()`内部创建了变量b,从而遮蔽了外部作用域中的b。

##### with语句

```js
var obj = {
	a:1,
	b:2,
	c:3
}

with(obj){
	a = 3;
	b = 4;
	c = 5;
}
```

with的本质在于将一个对象的引用当作作用域来处理，将对象的属性当做作用域中的标识符来处理。

**不要使用eval和with**

### 函数作用域和块级作用域

函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数内被访问到（函数外则不能）。

#### 隐藏内部实现

```js
function doSomething(a){
	b = a + doSomethingElse(a * 2);
	console.log(b * 3);
}

function doSomethingElse(a){
	return a - 1;
}

var b;
doSomething(2);   //15
```

在这个代码片段中,b和doSomethingElse都应该是doSomething的私有内容，而现在他们可以被外界其他函数调用更改。我们可以做一些修改，利用作用域来保护他们。

```js
function doSomething(a){
	function doSomethingElse(a){
		return a -1;
	}
	var b;
	b = a + doSomethingElse(a*2);
	console.log(b*3);
}

doSomething(2);  //15
```

在这个新的例子中，b和doSomethingElse只有doSomething可以使用了，无法从外部访问到。

#### 规避冲突

如果发生标识符命名想同的情况，那么可能出现难以被发现的bug，一些变量的值会被意外覆盖。

一个比较好的方法是声明一个名字足够独特的对象，然后所有功能都会是这个对象的属性，这样标识符就不会暴露在顶级词法作用域当中。

#### 函数表达式

*一个最简单区分函数表达式和函数声明的方法就是看function关键字出现在声明中的位置。如果function是声明中的第一个词，那么就是函数声明，否则就是函数表达式*

函数表达式的意义在于可以避免污染所在作用域。比如回调函数中使用的匿名函数和立即执行函数表达式（IIFE）都可以实现保护自身内部变量不被外部访问的同时自己本身也不会污染全局作用域。

#### 块作用域

js中有几种情况会创建块作用域

1. with
2. try-catch   catch中声明的变量仅仅只在catch中有效
3. let与const

拥有块作用域的变量只在某个代码块中可以被访问（通常指{...}内部）。

### 提升

提升指的是变量和函数的声明会被移动到作用域的最顶端,但函数表达式和赋值操作并不会被提升。

一些特别注意的点：

+ 函数声明优先于变量声明
+ 重复的变量声明会被忽略
+ 后面的函数声明会覆盖前面的同名函数声明

例如：

```js
foo();  //1

var  foo;

function foo(){
	console.log(1);
}

foo = function(){
	console.log(2);
}
```

在这个例子中同时出现了名为foo的函数和变量，那么变量声明就被忽略掉了。

## 闭包

闭包是基于词法作用域书写代码所产生的自然结果，一个简单的例子如下：

```js
function foo(){
	var a = 2;
	
	function bar(){
		console.log(a);
	}
	
	return bar;
}

var baz = foo();

baz();  //2  这就是闭包
```

bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当做一个值类型进行传递。在这个例子中，我们将bar所引用的函数对象本身当做返回值。bar()显然可以被执行，但是在这个例子中，它在自己定义的词法作用域外执行。在foo()执行以后，通常foo()的整个内部作用域都会被销毁。而闭包则会阻止这个事情的发生，事实上内部作用域仍然存在，bar()在使用它。bar()拥有涵盖foo()内部作用域的闭包，使得作用域能够一直存活，以供bar()可以在任意时间调用。

无论通过何种手段将内部函数传递到所在词法作用域以外，它都会持有对原始作用域的引用。这就是闭包的效果。

### 闭包与循环

一个经典的问题：

```js
for(var i=1; i<=5; i++){
	setTimeout(function timer(){
		console.log( i );
	},i*1000);
}
```

这个循环将打印出一串6。我们往往会假设每次迭代在运行中都会给自己捕获一个i的副本。但是根据作用域的工作原理，从始至终只有一个i。

如果我们对代码进行一点点更改：

```js
for(var i=1; i<=5; i++){
	(function(){
		setTimeout(function timer(){
			console.log(i);
		},i*1000);
	})()
}
```

这样的更改并不会影响结果。虽然每次IIFE创建的作用域都会被封闭，看似我们拥有了更多的词法作用域。但实际上这个作用域中没有任何标识符，所以还不够。

```js
for(var i=1; i<=5; i++){
	(function(){
		var j = i;
		setTimeout(function timer(){
			console.log(j);
		},j*1000);
	})();
}
```

这样我们就可以打印出预想中的123456。本质在于每次IIFE都生成了新的作用域封闭了j的值。

#### 重返块作用域

这个问题的最简单的更改就是使用let代替var，相当于每次迭代都创造了一个块作用域。

### 动态作用域

从一段代码开始

```js
function foo(){
	console.log(a);
}

function bar(){
	var a = 3;
	foo();
}

var a = 2;

bar();
```

按js的词法作用域，此处会输出2。因为每个函数声明会创造一个作用域泡，当执行foo的时候会向上寻找a，最后找到全局作用域上的a。

如果js拥有动态作用域，那么会输出3。动态作用域基于调用栈工作，只关心从何处调用而非在哪里声明。

简明的说，词法作用域在定义时就确定了，而动态作用域在运行时才确定。





​                       