## 作用域

### 编译原理

尽管通常将JavaScript归类为“动态”或“解释执行”语言，但实际上它是一门编译语言。但与传统的编译语言不同，JavaScript不是提前编译的，编译结果也不能在分布式系统中进行移植。

对一般的编译语言来说，编译过程包括三个部分

1. 分词/词法分析(Tokenizing/Lexing)

2. 解析/语法分析(Parsing)

3. 代码生成

而对于JS引擎来说，它不会有大量的时间来对代码进行优化，它的编译过程往往发生在执行前的几微秒甚至更短。

### LHS与RHS

当变量出现在赋值操作左侧时会进行LHS查询，出现在右侧则进行RHS查询。更好理解的说法是：赋值操作的目标是谁（LHS）以及谁是赋值操作的源头(RHS)。

LHS和RHS查询都会从当前执行作用域开始，如果有需要（没有在当前作用域找到标识符），就会继续向上级作用域查找标识符，直到抵达全局作用域。

不成功的RHS会抛出ReferenceError异常，而不成功的LHS会导致隐式创建一个全局变量（非严格模式下）。

### 词法作用域

#### 查找

作用域查找会从运行时的最内部作用域开始，逐级向外或者说向上开始查询，直到遇到第一个匹配的标识符开始。

（如果多层嵌套的作用域内定义了同名的标识符，则会发生“遮蔽”）。

*全局变量会自动成为全局对象的属性，可以直接通过对全局对象属性的引用来进行访问 例如window.a*

#### 欺骗词法

有两种机制可以修改一般情况下的词法作用域

*但是欺骗词法作用域会导致性能下降*

##### eval语句

```js
function foo(str,a){
	eval(str);
	console.log(a,b);
}
var b = 2;

foo("var b = 3;",1)   //1,3
```

eval语句会使`var b = 3;`就像原本就在eval语句处那样，因此它实际对`foo()`的词法作用域做出了修改。本质上，它在`foo()`内部创建了变量b,从而遮蔽了外部作用域中的b。

##### with语句

```js
var obj = {
	a:1,
	b:2,
	c:3
}

with(obj){
	a = 3;
	b = 4;
	c = 5;
}
```

with的本质在于将一个对象的引用当作作用域来处理，将对象的属性当做作用域中的标识符来处理。

**不要使用eval和with**

### 函数作用域和块级作用域

函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数内被访问到（函数外则不能）。

#### 隐藏内部实现

```js
function doSomething(a){
	b = a + doSomethingElse(a * 2);
	console.log(b * 3);
}

function doSomethingElse(a){
	return a - 1;
}

var b;
doSomething(2);   //15
```

在这个代码片段中,b和doSomethingElse都应该是doSomething的私有内容，而现在他们可以被外界其他函数调用更改。我们可以做一些修改，利用作用域来保护他们。

```js
function doSomething(a){
	function doSomethingElse(a){
		return a -1;
	}
	var b;
	b = a + doSomethingElse(a*2);
	console.log(b*3);
}

doSomething(2);  //15
```

在这个新的例子中，b和doSomethingElse只有doSomething可以使用了，无法从外部访问到。

#### 规避冲突

如果发生标识符命名想同的情况，那么可能出现难以被发现的bug，一些变量的值会被意外覆盖。

一个比较好的方法是声明一个名字足够独特的对象，然后所有功能都会是这个对象的属性，这样标识符就不会暴露在顶级词法作用域当中。

#### 函数表达式

*一个最简单区分函数表达式和函数声明的方法就是看function关键字出现在声明中的位置。如果function是声明中的第一个词，那么就是函数声明，否则就是函数表达式*

函数表达式的意义在于可以避免污染所在作用域。比如回调函数中使用的匿名函数和立即执行函数表达式（IIFE）都可以实现保护自身内部变量不被外部访问的同时自己本身也不会污染全局作用域。

#### 块作用域

js中有几种情况会创建块作用域

1. with
2. try-catch   catch中声明的变量仅仅只在catch中有效
3. let与const

拥有块作用域的变量只在某个代码块中可以被访问（通常指{...}内部）。

### 提升

提升指的是变量和函数的声明会被移动到作用域的最顶端,但函数表达式和赋值操作并不会被提升。

一些特别注意的点：

+ 函数声明优先于变量声明
+ 重复的变量声明会被忽略
+ 后面的函数声明会覆盖前面的同名函数声明

例如：

```js
foo();  //1

var  foo;

function foo(){
	console.log(1);
}

foo = function(){
	console.log(2);
}
```

在这个例子中同时出现了名为foo的函数和变量，那么变量声明就被忽略掉了。



